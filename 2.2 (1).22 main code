{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "50cc30c6",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import re\n",
    "import dns\n",
    "import pymongo\n",
    "\n",
    "from slack_bolt import App\n",
    "from slack_bolt.adapter.socket_mode import SocketModeHandler\n",
    "from datetime import datetime\n",
    "from pymongo import MongoClient\n",
    "from fpdf import FPDF\n",
    "from textblob import TextBlob\n",
    "\n",
    "#pip install slack_bolt\n",
    "#pip install fpdf\n",
    "#conda install dnspython\n",
    "#pip install textblob\n",
    "#pip install pymongo[srv]\n",
    "\n",
    "\n",
    "client = pymongo.MongoClient(\"mongodb+srv://structurelyusername:structurelypassword@structurely1.naagl.mongodb.net/myFirstDatabase?retryWrites=true&w=majority\")\n",
    "db = client.test\n",
    "collection = db[\"slack\"]\n",
    "\n",
    "app = App(token=\"xoxb-2970213766022-2976934764882-pf5VMdXnTiE1N4mAdFAKQevk\")\n",
    "\n",
    "total_leads = 0\n",
    "total_leads_annotated = 0\n",
    "total_leads_approved = 0\n",
    "\n",
    "def text_parse(message_temp):\n",
    "    global message1 \n",
    "    message = message1\n",
    "    words = message.split() \n",
    "    bot_message = []\n",
    "    lead_message = []\n",
    "    intents_lst = []\n",
    "    a_dict = {}\n",
    "    \n",
    "    if 'New intents approved' in message:\n",
    "        passed = 0\n",
    "    if 'Prediction approved' in message:\n",
    "        passed = 1\n",
    "    \n",
    "    vinny_id_temp = words.index(\"id:\")\n",
    "    vinny_id_temp +=1\n",
    "    vinny_id = words[vinny_id_temp]\n",
    "    ###vinny id var\n",
    "\n",
    "    lead_types_temp = words.index(\"types:\")\n",
    "    lead_types_temp +=1\n",
    "    lead_type_db = words[lead_types_temp]\n",
    "    ###lead type var\n",
    "\n",
    "    context_temp = words.index(\"Context:\")\n",
    "    context_temp +=1\n",
    "    context_db = words[context_temp]\n",
    "    ###context var\n",
    "\n",
    "    body_temp = words.index(\":robot_face:\")\n",
    "    print(\"Bot Message:\")\n",
    "    while words[body_temp] != \":speech_balloon:\":\n",
    "        body_temp += 1\n",
    "        bot_message.append(words[body_temp])\n",
    "    \n",
    "    del bot_message[0]\n",
    "    del bot_message[0]\n",
    "    del bot_message[0]\n",
    "    del bot_message[-1]\n",
    "    bot_message_str = ' '.join(bot_message)\n",
    "    ### bot message var\n",
    "\n",
    "    lead_temp = words.index(\":speech_balloon:\")\n",
    "    print(\"Lead Message:\")\n",
    "    while words[lead_temp] != \"Predicted\":\n",
    "        lead_temp += 1\n",
    "        lead_message.append(words[lead_temp])\n",
    "    \n",
    "    del lead_message[0]\n",
    "    del lead_message[0]\n",
    "    del lead_message[-1] \n",
    "    lead_message_str = ' '.join(lead_message)\n",
    "    ###lead message var\n",
    "\n",
    "    intents_temp = words.index(\"Predicted\")\n",
    "    print(\"Slots and Intents:\")\n",
    "    while intents_temp < len(words)-1:\n",
    "        intents_temp += 1\n",
    "        intents_lst.append(words[intents_temp])\n",
    "\n",
    "    intents_str = ' '.join(intents_lst)\n",
    "    ###intents var\n",
    "    \n",
    "    for variable in [\"vinny_id\", \"lead_type_db\", \"context_db\", \"bot_message_str\", \"lead_message_str\", \"intents_str\", \"passed\", \"sentiment_polarity\", \"sentiment_subjectivity\"]:\n",
    "    a_dict[variable] = eval(variable)\n",
    "    return a_dict\n",
    "    \n",
    "\n",
    "def metric_track(message_temp):\n",
    "    global total_leads\n",
    "    global total_leads_annotated\n",
    "    global total_leads_approved\n",
    "    global message1\n",
    "    \n",
    "    message_str = message_temp\n",
    "        \n",
    "    text_parse()\n",
    "        \n",
    "    print(a_dict)\n",
    "\n",
    "    post = a_dict\n",
    "    collection.insert_one(post)    \n",
    "    \n",
    "\n",
    "def sentiment_report_gen():\n",
    "     # 1. Set up the PDF doc basics\n",
    "    pdf = FPDF()\n",
    "    pdf.add_page()\n",
    "    pdf.set_font('Arial', 'B', 16)\n",
    "\n",
    "    # 2. Layout the PDF doc contents\n",
    "    ## Title\n",
    "    pdf.cell(40, 10, 'Slack Sentiment Report')\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Image\n",
    "    pdf.image('sentiment_chart.png')\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Show table of historical data\n",
    "    ### Transform the DataFrame to include index of Date\n",
    "    sp500_history_pdf = sp500_history.reset_index()\n",
    "    ### Transform the Date column as str dtype\n",
    "    sp500_history_pdf['Date'] = sp500_history_pdf['Date'].astype(str)\n",
    "    ### Round the numeric columns to 2 decimals\n",
    "    numeric_cols = sp500_history_pdf.select_dtypes(include='number').columns\n",
    "    sp500_history_pdf[numeric_cols] = sp500_history_pdf[numeric_cols].round(2)\n",
    "    ### Use the function defined earlier to print the DataFrame as a table on the PDF \n",
    "    output_df_to_pdf(pdf, sp500_history_pdf.tail(3))\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Show table of historical summary data\n",
    "    sp500_history_summary_pdf = sp500_history_summary.reset_index()\n",
    "    numeric_cols = sp500_history_summary_pdf.select_dtypes(include='number').columns\n",
    "    sp500_history_summary_pdf[numeric_cols] = sp500_history_summary_pdf[numeric_cols].round(2)\n",
    "\n",
    "    output_df_to_pdf(pdf, sp500_history_summary_pdf)\n",
    "    # 3. Output the PDF file\n",
    "    pdf.output('fpdf_pdf_report.pdf', 'F')\n",
    "    \n",
    "    \n",
    "    \n",
    "def metric_report_gen():\n",
    "     # 1. Set up the PDF doc basics\n",
    "    pdf = FPDF()\n",
    "    pdf.add_page()\n",
    "    pdf.set_font('Arial', 'B', 16)\n",
    "\n",
    "    # 2. Layout the PDF doc contents\n",
    "    ## Title\n",
    "    pdf.cell(40, 10, 'Slack Metrics Report')\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Image\n",
    "    pdf.image('metric_chart.png')\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Show table of historical data\n",
    "    ### Transform the DataFrame to include index of Date\n",
    "    sp500_history_pdf = sp500_history.reset_index()\n",
    "    ### Transform the Date column as str dtype\n",
    "    sp500_history_pdf['Date'] = sp500_history_pdf['Date'].astype(str)\n",
    "    ### Round the numeric columns to 2 decimals\n",
    "    numeric_cols = sp500_history_pdf.select_dtypes(include='number').columns\n",
    "    sp500_history_pdf[numeric_cols] = sp500_history_pdf[numeric_cols].round(2)\n",
    "    ### Use the function defined earlier to print the DataFrame as a table on the PDF \n",
    "    output_df_to_pdf(pdf, sp500_history_pdf.tail(3))\n",
    "    ## Line breaks\n",
    "    pdf.ln(20)\n",
    "    ## Show table of historical summary data\n",
    "    sp500_history_summary_pdf = sp500_history_summary.reset_index()\n",
    "    numeric_cols = sp500_history_summary_pdf.select_dtypes(include='number').columns\n",
    "    sp500_history_summary_pdf[numeric_cols] = sp500_history_summary_pdf[numeric_cols].round(2)\n",
    "\n",
    "    output_df_to_pdf(pdf, sp500_history_summary_pdf)\n",
    "    # 3. Output the PDF file\n",
    "    pdf.output('fpdf_pdf_report.pdf', 'F')\n",
    "\n",
    "@app.event({\n",
    "    \"type\": \"message\",\n",
    "    \"subtype\": \"message_changed\"\n",
    "})\n",
    "def message_tracker(event, say):\n",
    "    global message2\n",
    "    message1 = event['message']\n",
    "    message2 = message1['text']\n",
    "    if ':white_check_mark:' in message2:\n",
    "        metric_track(message2)\n",
    "        \n",
    "@app.event({\"type\": \"message\"}, middleware=[extract_subtype])\n",
    "def just_ack(logger, context):\n",
    "    subtype = context[\"subtype\"] \n",
    "\n",
    "        \n",
    "@app.command(\"/sentiment report\")\n",
    "def sentiment_report(ack, respond, command):\n",
    "    current_date_time = datetime.now().strftime(\"%Y_%m_%d-%I_%M_%S_%p\")\n",
    "    \n",
    "    ack(\"Generating Sentiment Report...\")\n",
    "        \n",
    "    #sentiment_report_gen()\n",
    "        \n",
    "    #file_name = (\"report_gen\" + current_date_time)\n",
    "            \n",
    "    #channel_id = \"vinny-analysis\"\n",
    "        \n",
    "    #result = client.files_upload(channels = channel_id,initial_comment = (\"Here is your report for:\" + current_date_time),\n",
    "    #file=file_name\n",
    "        \n",
    "@app.command(\"/metric report\")\n",
    "def metric_report(ack, respond, command): \n",
    "    current_date_time = datetime.now().strftime(\"%Y_%m_%d-%I_%M_%S_%p\")\n",
    "        \n",
    "    ack(\"Generating Metric Report...\")\n",
    "        \n",
    "    #metric_report_gen()\n",
    "    \n",
    "    #file_name = ('report_gen' + current_date_time)\n",
    "\n",
    "    #channel_id = \"vinny-analysis\"\n",
    "            \n",
    "    #result = client.files_upload(\n",
    "    #channels = channel_id,\n",
    "    #initial_comment = (\"Here is your report for:\" + current_date_time)\n",
    "    #file=file_name\n",
    "\n",
    "    \n",
    "if __name__ == \"__main__\":\n",
    "    SocketModeHandler(app, \"xapp-1-A02UJ6YTLEA-3023246363889-a2fddf4485c6ab0be3d7a7586522a0d446dce8f9cd82012d887abe21c2655eed\").start()\n",
    "   "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
